/*
First step towards evolution:
 
 
 Create a new class consisting of all the weights, limits, and other fixed numbers that might make up an individual vehicle's personality.
 You may invent new ones (size? color?) Do not include velocity or location. Call this new class DNA.
 
 Each vehicle gets its own DNA object
 
 The constructor for a vehicle should take the DNA as an argument, along with any other necessary information you wish (such as initial location)
 
 Create a new method in the Vehicle class called getDNA() which returns a vehicle's DNA object
 
 In order to simulate selection, in each frame, some vehicles do not survive, and some vehicles are copied.
 - Each vehicle is checked in some way, and some vehicles do not survive to the next frame. You get to decide what criterion to use.
 Note that if selection works, then the criterion you use to determine whether a vehicle lives or dies will determine what features
 will be selected (e.g. if you chose to let vehicles die when they leave the canvas, then your system will select vehicles that
 stay on the canvas.) Be creative!
 - Write a method to test whether this vehicle survives or not.
 - How will you determine when vehicles are copied?
 - Think about what other changes will be necessary in order to simulate selection.
 
 Michael Shiloh
 February 20 2021
 
 Based on examples from The Nature of Code by Daniel Shiffman - Thanks Dan!
 
 This code is in the public domain
 */

ArrayList<Vehicle> vehicles = new ArrayList<Vehicle>();
Food food;

void setup() {
  size (1200, 800);

  food = new Food(width/2, height/2);


  // Make 100 vehicles to start with
  for (int i = 0; i < 100; i++) {
    vehicles.add(new Vehicle(random(width), random(height)));
  }
}

// If you want more vehicles. You could also add
// multiple vehicles for each click
void mouseClicked() {
  vehicles.add(new Vehicle(mouseX, mouseY));
}

void draw() {
  background(200);

  food.display();

  for (Vehicle v : vehicles) {
    v.simpleSeek(food.getLocation());
    v.feed(food.getLocation());
    v.consumeEnergy();
    v.separate(vehicles); 
    v.update(); // Update the velocity and location, based on the acceleration generated by the steering force
    v.display(); // display the vehicle
  }
}
